<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EnigmaJS - Encrypted P2P Chat</title>
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Barlow:wght@400;600;700;900&display=swap');
    
    :root {
      --bg-gradient-start: #FF6B35;
      --bg-gradient-end: #F7931E;
      --container-bg: #FFFFFF;
      --text-primary: #1A1A1A;
      --text-secondary: #4A4A4A;
      --text-tertiary: #2A2A2A;
      --accent-primary: #FF6B35;
      --accent-secondary: #F7931E;
      --accent-tertiary: #FFB88C;
      --input-border: #FFB88C;
      --input-bg: #FAFAFA;
      --section-bg: #FFF5F0;
      --btn-secondary-bg: #FFE5D9;
      --btn-secondary-hover: #FFD4BF;
      --status-disconnected-bg: #FFE5E5;
      --status-disconnected-text: #D32F2F;
      --status-disconnected-border: #D32F2F;
      --status-waiting-bg: #FFF8E1;
      --status-waiting-text: #F57C00;
      --status-waiting-border: #F57C00;
      --status-connected-bg: #E8F5E9;
      --status-connected-text: #388E3C;
      --status-connected-border: #388E3C;
      --peer-id-bg: #FFE5D9;
      --connection-info-bg: #FFF5F0;
      --info-border: #FFD4BF;
      --chat-messages-bg: #FAFAFA;
      --chat-messages-border: #FFD4BF;
      --debug-toggle-bg: #FFF5F0;
      --debug-toggle-hover: #FFE5D9;
      --shadow-color: rgba(255, 107, 53, 0.2);
      --qr-bg: #1A1A1A;
    }

    body.dark-mode {
      --bg-gradient-start: #1A1A1A;
      --bg-gradient-end: #2A2A2A;
      --container-bg: #0D0D0D;
      --text-primary: #FFFFFF;
      --text-secondary: #B8B8B8;
      --text-tertiary: #E0E0E0;
      --accent-primary: #FF6B35;
      --accent-secondary: #F7931E;
      --accent-tertiary: #D4571F;
      --input-border: #3D3D3D;
      --input-bg: #1A1A1A;
      --section-bg: #161616;
      --btn-secondary-bg: #2A2A2A;
      --btn-secondary-hover: #3D3D3D;
      --status-disconnected-bg: #2A1515;
      --status-disconnected-text: #FF6B6B;
      --status-disconnected-border: #FF6B6B;
      --status-waiting-bg: #2A2515;
      --status-waiting-text: #FFB347;
      --status-waiting-border: #FFB347;
      --status-connected-bg: #152A15;
      --status-connected-text: #69F0AE;
      --status-connected-border: #69F0AE;
      --peer-id-bg: #2A1F1A;
      --connection-info-bg: #1A1A1A;
      --info-border: #3D3D3D;
      --chat-messages-bg: #161616;
      --chat-messages-border: #3D3D3D;
      --debug-toggle-bg: #1A1A1A;
      --debug-toggle-hover: #2A2A2A;
      --shadow-color: rgba(0, 0, 0, 0.6);
      --qr-bg: #FFFFFF;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Barlow', 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
      min-height: 100vh;
      padding: 20px;
      color: var(--text-primary);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      transition: background 0.3s ease;
    }
    .container {
      max-width: 800px;
      width: 100%;
      margin: 40px auto;
      background: var(--container-bg);
      border-radius: 20px;
      box-shadow: 0 20px 60px var(--shadow-color);
      padding: 30px 20px 30px 20px;
      min-height: 80vh;
      transition: background 0.3s ease;
      border: 2px solid var(--accent-tertiary);
    }
    h1 {
      text-align: center;
      background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0;
      font-size: 2.5em;
      font-weight: 900;
      letter-spacing: -1px;
      text-transform: uppercase;
    }
    h2 {
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--accent-primary);
    }
    h3 {
      font-weight: 700;
      color: var(--text-primary);
    }
    .subtitle {
      text-align: center;
      color: var(--text-secondary);
      margin-bottom: 30px;
      font-size: 1em;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .mode-selector {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      justify-content: center;
    }
    button {
      padding: 14px 28px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: 'Barlow', sans-serif;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
    }
    .btn-primary:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4);
    }
    .btn-secondary {
      background: var(--btn-secondary-bg);
      color: var(--text-primary);
    }
    .btn-secondary:hover {
      background: var(--btn-secondary-hover);
    }
    .section {
      margin-bottom: 25px;
      padding: 24px;
      background: var(--section-bg);
      border-radius: 16px;
      display: none;
      border: 2px solid var(--accent-tertiary);
    }
    .section.active {
      display: block;
    }
    #qrcode, [id^="promoted-qrcode-"] {
      display: flex;
      justify-content: center;
      margin: 20px 0;
      padding: 20px;
      background: var(--qr-bg);
      border-radius: 12px;
      border: 2px solid var(--accent-tertiary);
    }
    .promoted-host-info {
      margin-top: 10px;
    }
    #video {
      width: 100%;
      max-width: 400px;
      border-radius: 8px;
      margin: 0 auto;
      display: block;
    }
    .status {
      padding: 16px;
      border-radius: 12px;
      margin: 15px 0;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-size: 14px;
    }
    .status.disconnected {
      background: var(--status-disconnected-bg);
      color: var(--status-disconnected-text);
      border-left: 4px solid var(--status-disconnected-border);
    }
    .status.connecting {
      background: #ffeaa7;
      color: #d63031;
      border-left: 4px solid #fdcb6e;
    }
    .status.waiting {
      background: var(--status-waiting-bg);
      color: var(--status-waiting-text);
      border-left: 4px solid var(--status-waiting-border);
    }
    .status.connected {
      background: var(--status-connected-bg);
      color: var(--status-connected-text);
      border-left: 4px solid var(--status-connected-border);
    }
    .log-console {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      max-height: 300px;
      overflow-y: auto;
      margin-top: 15px;
    }
    .log-entry {
      margin: 5px 0;
      padding: 3px 0;
      border-bottom: 1px solid #333;
    }
    .log-time {
      color: #858585;
      margin-right: 10px;
    }
    .log-info { color: #4fc3f7; }
    .log-success { color: #81c784; }
    .log-warn { color: #ffb74d; }
    .log-error { color: #e57373; }
    .debug-panel {
      margin-top: 20px;
      border-top: 2px solid var(--info-border);
      padding-top: 15px;
    }
    .debug-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 15px;
      background: var(--debug-toggle-bg);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .debug-toggle:hover {
      background: var(--debug-toggle-hover);
    }
    .debug-toggle-text {
      font-weight: 600;
      color: var(--text-tertiary);
      font-size: 14px;
    }
    .debug-toggle-icon {
      transition: transform 0.3s;
      font-size: 18px;
      color: var(--accent-primary);
    }
    .debug-toggle-icon.expanded {
      transform: rotate(180deg);
    }
    .debug-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    .debug-content.expanded {
      max-height: 800px;
    }
    .header-row {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }
    .header-center {
      grid-column: 2;
      text-align: center;
    }
    .header-right {
      grid-column: 3;
      display: flex;
      justify-content: flex-end;
    }
    .logo-link {
      text-decoration: none;
      color: inherit;
      cursor: pointer;
      display: inline-block;
      transition: transform 0.2s;
    }
    .logo-link:hover {
      transform: scale(1.05);
    }
    .dark-mode-toggle {
      background: var(--btn-secondary-bg);
      border: 2px solid var(--input-border);
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .dark-mode-toggle:hover {
      background: var(--btn-secondary-hover);
      transform: translateY(-2px);
    }
    .peer-id {
      background: var(--peer-id-bg);
      padding: 10px;
      border-radius: 6px;
      margin: 10px 0;
      font-family: monospace;
      word-break: break-all;
      font-size: 14px;
    }
    .connection-info {
      background: var(--connection-info-bg);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0 0 0;
      font-size: 13px;
    }
    .security-info {
      background: var(--section-bg);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      border: 2px solid var(--accent-tertiary);
    }
    .security-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 2px solid var(--accent-tertiary);
    }
    .security-title {
      font-weight: 700;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--accent-primary);
    }
    .security-badge {
      background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      color: white;
      padding: 4px 10px;
      border-radius: 12px;
      font-weight: 700;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .security-badge.active {
      background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%);
    }
    .security-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      font-size: 13px;
    }
    .security-label {
      font-weight: 600;
      color: var(--text-secondary);
    }
    .security-value {
      font-weight: 700;
      color: var(--text-primary);
      font-family: monospace;
      font-size: 12px;
    }
    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid var(--info-border);
    }
    .info-row:last-child {
      border-bottom: none;
    }
    .info-label {
      font-weight: 600;
      color: var(--text-tertiary);
    }
    .info-value {
      font-family: monospace;
      color: var(--text-primary);
      text-align: right;
      word-break: break-all;
      max-width: 60%;
      font-size: 12px;
    }
    .chat-area {
      margin-top: 20px;
    }
    .chat-messages {
      background: var(--chat-messages-bg);
      border: 1px solid var(--chat-messages-border);
      border-radius: 8px;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 10px;
    }
    .message {
      padding: 12px 16px;
      margin: 8px 0;
      border-radius: 18px;
      max-width: 80%;
      font-weight: 500;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .message.sent {
      margin-left: auto;
      text-align: right;
    }
    .message-sender {
      font-size: 11px;
      opacity: 0.7;
      margin-bottom: 3px;
    }
    .message-input-container {
      display: flex;
      gap: 8px;
    }
    .message-input {
      flex: 1;
      padding: 14px;
      border: 2px solid var(--input-border);
      border-radius: 12px;
      font-family: 'Barlow', sans-serif;
      font-size: 15px;
      background: var(--input-bg);
      color: var(--text-primary);
      font-weight: 500;
      transition: border 0.3s;
    }
    .message-input:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.1);
    }
    .user-list-panel {
      background: var(--section-bg);
      border-radius: 12px;
      padding: 16px;
      margin-top: 20px;
      border: 2px solid var(--accent-tertiary);
    }
    .user-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 2px solid var(--accent-tertiary);
    }
    .user-list-title {
      font-weight: 700;
      font-size: 16px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--accent-primary);
    }
    .user-count {
      background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-weight: 700;
      font-size: 12px;
      text-transform: uppercase;
    }
    .user-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .user-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      border-radius: 8px;
      background: var(--input-bg);
      transition: transform 0.2s;
    }
    .user-item:hover {
      transform: translateX(4px);
    }
    .user-color-dot {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      flex-shrink: 0;
      border: 2px solid var(--container-bg);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    .user-name {
      font-weight: 600;
      font-size: 14px;
      color: var(--text-primary);
      flex: 1;
    }
    .user-badge {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 12px;
      background: var(--peer-id-bg);
      color: var(--text-secondary);
      font-weight: 600;
      text-transform: uppercase;
    }
    .user-kick-btn {
      background: #EF5350;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 11px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
      text-transform: uppercase;
    }
    .user-kick-btn:hover {
      background: #E53935;
      transform: scale(1.05);
    }
    .user-promote-btn {
      background: var(--accent-primary);
      color: white;
      border: none;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 11px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
      text-transform: uppercase;
      margin-right: 4px;
    }
    .user-promote-btn:hover {
      background: var(--accent-secondary);
      transform: scale(1.05);
    }
    .scroll-to-bottom {
      position: absolute;
      bottom: 70px;
      right: 20px;
      background: var(--container-bg);
      color: var(--accent-primary);
      border: 2px solid var(--accent-primary);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      transition: all 0.2s ease;
      display: none;
      z-index: 100;
      align-items: center;
      justify-content: center;
    }
    .scroll-to-bottom:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
      background: var(--accent-primary);
      color: white;
    }
    .scroll-to-bottom.visible {
      display: flex;
    }
    .chat-area {
      position: relative;
    }
    @media (max-width: 600px) {
      .container {
        padding: 10px;
      }
      .chat-messages {
        padding: 8px;
      }
      .message-input {
        font-size: 12px;
        padding: 8px;
      }
      button {
        font-size: 14px;
        padding: 8px 12px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header-row">
      <div></div>
      <div class="header-center">
        <a href="index.html" class="logo-link" title="Reload EnigmaJS">
          <h1>üîê EnigmaJS</h1>
        </a>
      </div>
      <div class="header-right">
        <button class="dark-mode-toggle" onclick="app.toggleDarkMode()" title="Toggle Dark Mode">
          <span id="theme-icon">üåô</span>
        </button>
      </div>
    </div>
    <p class="subtitle">Secure web-based chat</p>

      <div style="text-align: center; margin-bottom: 30px; padding: 15px; background: var(--section-bg); border-radius: 8px;">
        <p style="margin: 0; color: var(--text-secondary); font-size: 0.95em;">
        <strong>üîí Private & Secure:</strong> End-to-end encrypted messaging with no data stored anywhere.
        <br>
        <strong>üåê Decentralized:</strong> Powered by Gun.js peer-to-peer network.
        </p>
      </div>
    
    <div id="username-setup" class="section active">
      <h2>Welcome!</h2>
      <p style="margin-bottom: 20px; color: #666;">First, choose your display name:</p>
      <div style="margin-bottom: 20px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #555;">Your Display Name:</label>
        <input type="text" id="user-display-name" placeholder="Enter your name..." maxlength="20" style="width: 100%; padding: 12px; border: 2px solid #667eea; border-radius: 8px; font-size: 14px;">
      </div>
      <button class="btn-primary" onclick="app.setUsername()" style="width: 100%;">Continue</button>
    </div>
    
    <div id="mode-selection" style="display: none;">
      <div class="mode-selector">
        <button class="btn-primary" onclick="app.setMode('host')">üè† Host Connection</button>
        <button class="btn-primary" onclick="app.setMode('join')">üì± Join Connection</button>
      </div>
    </div>
    <div id="host-section" class="section">
      <h2>Host Mode</h2>
      <div id="status-host" class="status disconnected">‚è≥ Initializing...</div>
      <div id="host-room-info">
        <p>Your Room ID:</p>
        <div class="peer-id" id="peer-id"></div>
        <button class="btn-secondary" onclick="navigator.clipboard.writeText(document.getElementById('peer-id').textContent)" style="width: 100%; margin-top: 10px;">üìã Copy Room ID</button>
        <p style="margin-top: 15px; text-align: center; color: #666;">Scan this QR code to connect:</p>
        <div id="qrcode"></div>
      </div>
      
      <div id="host-user-list" class="user-list-panel" style="display: none;">
        <div class="user-list-header">
          <span class="user-list-title">üë• Connected Users</span>
          <span class="user-count" id="host-user-count">1</span>
        </div>
        <div class="user-list" id="host-users"></div>
      </div>
      
      <div id="host-chat" class="chat-area" style="display: none;">
        <h3>üí¨ Chat</h3>
        <div class="chat-messages" id="host-messages"></div>
        <button class="scroll-to-bottom" id="host-scroll-btn" onclick="app.scrollToBottom('host')" title="Scroll to bottom">‚Üì</button>
        <div class="message-input-container">
          <input type="text" id="host-input" class="message-input" placeholder="Type a message..." onkeypress="if(event.key==='Enter') app.sendMessage()">
          <button class="btn-primary" onclick="app.sendMessage()">Send</button>
        </div>
      </div>
      
      <div class="debug-panel">
        <div class="debug-toggle" onclick="app.toggleDebugPanel('host')">
          <span class="debug-toggle-text">üîß Debug Info & Logs</span>
          <span class="debug-toggle-icon" id="debug-icon-host">‚ñº</span>
        </div>
        <div class="debug-content" id="debug-content-host">
          <div id="security-info-host" class="security-info">
            <div class="security-header">
              <span class="security-title">üîí Security</span>
              <span class="security-badge" id="security-badge-host">NOT CONNECTED</span>
            </div>
            <div class="security-item">
              <span class="security-label">Status:</span>
              <span class="security-value" id="conn-status-host">Disconnected</span>
            </div>
            <div class="security-item">
              <span class="security-label">Role:</span>
              <span class="security-value" id="conn-role-host">‚Äî</span>
            </div>
            <div class="security-item">
              <span class="security-label">Room:</span>
              <span class="security-value" id="conn-room-host">‚Äî</span>
            </div>
            <div class="security-item">
              <span class="security-label">Users:</span>
              <span class="security-value" id="conn-peers-host">0</span>
            </div>
            <div class="security-item">
              <span class="security-label">Messages:</span>
              <span class="security-value" id="conn-messages-host">0</span>
            </div>
          </div>
          <div style="margin: 15px 0; text-align: right;">
            <label style="cursor: pointer; font-size: 14px;">
              <input type="checkbox" id="verbose-toggle-host" onchange="app.toggleVerbose(this.checked)"> Verbose Logging
            </label>
          </div>
          <div class="log-console" id="log-console-host"></div>
        </div>
      </div>
    </div>
    <div id="join-section" class="section">
      <h2>Join Mode</h2>
      <div id="status-join" class="status disconnected">üìù Ready to connect</div>
      <div id="join-input-section">
        <div style="margin: 20px 0;">
          <p style="margin-bottom: 10px; font-weight: 600;">Enter Host Room ID:</p>
          <input type="text" id="peer-id-input" placeholder="Paste room ID here" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-family: monospace; font-size: 14px;">
          <button class="btn-primary" onclick="app.connectManual()" style="width: 100%; margin-top: 10px;">Connect</button>
        </div>
        <div style="text-align: center; margin: 20px 0; color: #999;">
          <span>‚Äî OR ‚Äî</span>
        </div>
        <div style="text-align: center;">
          <input type="file" id="qr-file-input" accept="image/*" style="display: none;" onchange="app.handleQRImage(event)">
          <button class="btn-secondary" onclick="document.getElementById('qr-file-input').click()" style="margin-bottom: 10px;">üìÅ Upload QR Image</button>
          <br>
          <button class="btn-secondary" onclick="app.startScanner()" id="start-camera-btn">üì∑ Scan with Camera</button>
          <button class="btn-secondary" onclick="app.stopScanner()" id="stop-camera-btn" style="display: none; background: #ff6b6b; color: white;">‚èπÔ∏è Stop Camera</button>
        </div>
        <canvas id="qr-canvas" style="display: none;"></canvas>
        <video id="video" autoplay playsinline style="display: none; max-width: 100%; border-radius: 8px; margin-top: 15px;"></video>
        <canvas id="canvas" style="display: none;"></canvas>
        <p id="scan-hint" style="display: none; text-align: center; color: #667eea; margin-top: 10px; font-weight: 600;">üéØ Point camera at QR code...</p>
      </div>
      
      <div id="join-user-list" class="user-list-panel" style="display: none;">
        <div class="user-list-header">
          <span class="user-list-title">üë• Connected Users</span>
          <span class="user-count" id="join-user-count">1</span>
        </div>
        <div class="user-list" id="join-users"></div>
      </div>
      
      <div id="join-chat" class="chat-area" style="display: none;">
        <h3>üí¨ Chat</h3>
        <div class="chat-messages" id="join-messages"></div>
        <button class="scroll-to-bottom" id="join-scroll-btn" onclick="app.scrollToBottom('join')" title="Scroll to bottom">‚Üì</button>
        <div class="message-input-container">
          <input type="text" id="join-input" class="message-input" placeholder="Type a message..." onkeypress="if(event.key==='Enter') app.sendMessage()">
          <button class="btn-primary" onclick="app.sendMessage()">Send</button>
        </div>
      </div>
      
      <div class="debug-panel">
        <div class="debug-toggle" onclick="app.toggleDebugPanel('join')">
          <span class="debug-toggle-text">üîß Debug Info & Logs</span>
          <span class="debug-toggle-icon" id="debug-icon-join">‚ñº</span>
        </div>
        <div class="debug-content" id="debug-content-join">
          <div id="security-info-join" class="security-info">
            <div class="security-header">
              <span class="security-title">üîí Security</span>
              <span class="security-badge" id="security-badge-join">NOT CONNECTED</span>
            </div>
            <div class="security-item">
              <span class="security-label">Status:</span>
              <span class="security-value" id="conn-status-join">Disconnected</span>
            </div>
            <div class="security-item">
              <span class="security-label">Role:</span>
              <span class="security-value" id="conn-role-join">‚Äî</span>
            </div>
            <div class="security-item">
              <span class="security-label">Room:</span>
              <span class="security-value" id="conn-room-join">‚Äî</span>
            </div>
            <div class="security-item">
              <span class="security-label">Users:</span>
              <span class="security-value" id="conn-peers-join">0</span>
            </div>
            <div class="security-item">
              <span class="security-label">Messages:</span>
              <span class="security-value" id="conn-messages-join">0</span>
            </div>
          </div>
          <div style="margin: 15px 0; text-align: right;">
            <label style="cursor: pointer; font-size: 14px;">
              <input type="checkbox" id="verbose-toggle-join" onchange="app.toggleVerbose(this.checked)"> Verbose Logging
            </label>
          </div>
          <div class="log-console" id="log-console-join"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // EnigmaJS - Encrypted P2P Chat using Gun.js SEA
    class EnigmaJS {
      constructor(options = {}) {
        this.gun = null;
        this.room = null;
        this.peerId = null;
        this.roomId = null;
        this.isHost = false;
        this.verbose = false;
        this.username = options.username || 'Anonymous';
        
        this.onLog = options.onLog || console.log;
        this.onStatusChange = options.onStatusChange || (() => {});
        this.onConnection = options.onConnection || (() => {});
        this.onConnectionInfo = options.onConnectionInfo || (() => {});
        this.onMessageReceived = options.onMessageReceived || (() => {});
        this.onPromoted = options.onPromoted || (() => {});
        
        this.status = 'disconnected';
        this.connected = false;
        this.peers = new Set();
        this.peerInfo = new Map(); // Store username and color for each peer
        this.peerLastSeen = new Map();
        this.processedMessages = new Set();
        this.messageCount = 0;
        this.lastMessageTime = null;
        
        // Gun SEA - full keypair for encryption and signing
        this.seaKeyPair = null;
        this.peerKeys = new Map(); // Store full SEA keys (epub) for each peer
        
        // Shared secret for group encryption (derived via SEA)
        this.sharedSecret = null;
        
        // Room management settings
        this.maxUsers = options.maxUsers || 10; // Default max 10 users
        this.roomPassword = null;
        this.kickedUsers = new Set(); // Track kicked user IDs
        this.joinedAt = null; // Timestamp when we joined the room
      }

      async initSEA() {
        this.seaKeyPair = await SEA.pair();
      }

      startPeerTimeoutChecker() {
        setInterval(() => {
          if (!this.connected || this.peers.size === 0) return;
          const now = Date.now();
          for (const peerId of this.peers) {
            const lastSeen = this.peerLastSeen.get(peerId) || now;
            if (now - lastSeen > 30000) {
              this.handlePeerLeave(peerId);
            }
          }
        }, 10000);
      }

      handlePeerLeave(peerId) {
        const info = this.peerInfo.get(peerId);
        const username = info ? info.username : 'Unknown';
        this.peers.delete(peerId);
        this.peerInfo.delete(peerId);
        this.peerKeys.delete(peerId);
        this.peerLastSeen.delete(peerId);
        this.log(`${username} left the room`, 'warn', true);
        this.updateConnectionInfo();
      }

      // Generate a consistent color from a string (username or peerId)
      // Colors constrained to warm spectrum (red/orange/yellow) to match Rockstar Energy Peach theme
      generateColorFromString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        
        // Constrain to warm colors (0-60 = red to orange to yellow)
        const hue = Math.abs(hash % 60);
        // Higher saturation for vibrant, energetic feel
        const saturation = 70 + (Math.abs(hash >> 8) % 25); // 70-95%
        // Balanced lightness for readability with vibrant colors
        const lightness = 60 + (Math.abs(hash >> 16) % 20); // 60-80%
        
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
      }

      // Calculate contrasting text color (black or white) based on background
      getContrastingTextColor(backgroundColor) {
        // Parse HSL color
        const match = backgroundColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
        if (!match) return '#000';
        
        const lightness = parseInt(match[3]);
        // If lightness > 60, use dark text, otherwise use light text
        return lightness > 60 ? '#000' : '#fff';
      }

      log(message, type = 'info', force = false) {
        // Filter verbose messages unless enabled or forced
        if (!force && !this.verbose && type === 'info') return;
        
        const timestamp = new Date().toLocaleTimeString();
        this.onLog({ timestamp, message, type });
      }

      setVerbose(enabled) {
        this.verbose = enabled;
        this.log(`Verbose logging ${enabled ? 'enabled' : 'disabled'}`, 'info', true);
      }

      setStatus(status, errorMsg = null) {
        this.status = status;
        this.onStatusChange(status, errorMsg);
        if (errorMsg) {
          this.log(`Status: ${status} - ${errorMsg}`, 'error', true);
        } else if (this.verbose) {
          this.log(`Status: ${status}`, 'info', true);
        }
      }

      generateId() {
        if (window.crypto && crypto.randomUUID) {
          return crypto.randomUUID();
        }
        return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }

      generatePeerId() {
        // Generate readable room/peer IDs like "FIRE-3K7-WXYZ"
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Exclude confusing chars (0, O, 1, I)
        const words = ['FIRE', 'BOLT', 'WAVE', 'STAR', 'NOVA', 'DASH', 'GLOW', 'ZOOM', 'APEX', 'CYAN', 
                       'ECHO', 'FLEX', 'VOLT', 'ZETA', 'BLUR', 'RUSH', 'FURY', 'BEAM', 'NEON', 'PEAK'];
        
        const word = words[Math.floor(Math.random() * words.length)];
        let segment1 = '';
        let segment2 = '';
        
        for (let i = 0; i < 3; i++) {
          segment1 += chars[Math.floor(Math.random() * chars.length)];
        }
        for (let i = 0; i < 4; i++) {
          segment2 += chars[Math.floor(Math.random() * chars.length)];
        }
        
        return `${word}-${segment1}-${segment2}`;
      }

      initGun() {
        const peers = [
          'https://gun-manhattan.herokuapp.com/gun',
          'https://gunjs.herokuapp.com/gun',
          'https://gun.o8.is/gun'
        ];
        
        this.gun = Gun({ peers, localStorage: false, radisk: false });
        if (this.verbose) {
          this.log(`Gun initialized with ${peers.length} relay peers`, 'success');
        }
      }

      async initHost() {
        this.setStatus('connecting');
        
        if (!this.seaKeyPair) {
          await this.initSEA();
          this.log('SEA keypair generated', 'info');
        }
        
        // Generate cryptographically secure password for room encryption
        const randomBytes = new Uint8Array(32);
        crypto.getRandomValues(randomBytes);
        this.sharedSecret = Array.from(randomBytes, byte => byte.toString(16).padStart(2, '0')).join('');
        this.log(`Room password generated (length: ${this.sharedSecret.length})`, 'info');
        
        this.peerId = this.generatePeerId();
        this.roomId = this.generatePeerId();
        this.isHost = true;
        this.joinedAt = Date.now();
        this.log(`Room ID: ${this.roomId}, Peer ID: ${this.peerId}`, 'info');
        
        this.initGun();
        this.room = this.gun.get('enigmajs').get(this.roomId);
        this.log('Gun network initialized, room created', 'info');
        
        this.setStatus('waiting');
        this.onConnection({ type: 'host-ready', peerId: this.roomId });
        this.log('Room created, waiting for connections...', 'success', true);
        this.setupMessageListener();
        this.log('Message listener active', 'info');
        this.updateConnectionInfo();
        this.startHeartbeat();
        this.startPeerTimeoutChecker();
      }

      async connectToPeer(roomId) {
        this.setStatus('connecting');
        
        if (!this.seaKeyPair) {
          await this.initSEA();
          this.log('SEA keypair generated', 'info');
        }
        
        this.peerId = this.generatePeerId();
        this.roomId = roomId;
        this.isHost = false;
        this.joinedAt = Date.now();
        this.log(`Peer ID: ${this.peerId}`, 'info');
        
        this.initGun();
        this.room = this.gun.get('enigmajs').get(this.roomId);
        this.log(`Connecting to room: ${this.roomId}`, 'info');
        
        this.setupMessageListener();
        this.log('Message listener active', 'info');
        
        // Send join message with SEA keys
        const joinMsg = {
          id: this.generateId(),
          type: 'join',
          sender: this.peerId,
          username: this.username,
          epub: this.seaKeyPair.epub, // Encryption public key
          pub: this.seaKeyPair.pub,   // Signing public key
          timestamp: Date.now()
        };
        this.room.get('messages').get(joinMsg.id).put(joinMsg);
        this.log(`Joining room with epub: ${this.seaKeyPair.epub.substring(0, 16)}...`, 'info');
        this.log('Joining room...', 'info', true);
        this.setStatus('waiting');
        this.updateConnectionInfo();
        this.startHeartbeat();
        this.startPeerTimeoutChecker();
      }

      startHeartbeat() {
        // Send ping every 30 seconds to keep connection alive (reduced from 15s)
        setInterval(() => {
          if (this.connected && this.room) {
            this.sendPing();
          }
        }, 30000);
      }

      setupMessageListener() {
        this.room.get('messages').map().on((data, key) => {
          if (!data || !data.id || !data.type || !data.sender) return;
          
          // Skip messages from before we joined (Gun replays history)
          if (data.timestamp && this.joinedAt && data.timestamp < this.joinedAt - 5000) {
            return; // Ignore messages from before we joined (5s grace period)
          }
          
          if (this.processedMessages.has(data.id)) {
            return;
          }
          this.processedMessages.add(data.id);
          
          if (data.sender === this.peerId) {
            return;
          }

          this.peerLastSeen.set(data.sender, Date.now());

          if (data.type === 'join') {
            this.log(`Received JOIN from ${data.username || data.sender}`, 'info');
            Promise.resolve(this.handleJoin(data));
          } else if (data.type === 'welcome') {
            this.log(`Received WELCOME from ${data.username || data.sender}`, 'info');
            Promise.resolve(this.handleWelcome(data));
          } else if (data.type === 'message') {
            // Only process messages if we have the shared secret
            if (this.sharedSecret) {
              Promise.resolve(this.handleMessage(data));
            }
          } else if (data.type === 'kick') {
            this.handleKick(data);
          } else if (data.type === 'kick-notify') {
            this.handleKickNotify(data);
          } else if (data.type === 'promote-notify') {
            this.handlePromoteNotify(data);
          } else if (data.type === 'ping') {
            this.handlePing(data);
          } else if (data.type === 'pong') {
            this.handlePong(data);
          }
        });
      }

      async handleJoin(data) {
        const displayName = data.username || 'Anonymous';
        
        // Check if user was kicked
        if (this.kickedUsers.has(data.sender)) {
          this.log(`Rejected join from kicked user: ${displayName}`, 'warn', true);
          return;
        }
        
        // Check room size limit (host)
        if (this.isHost && this.peers.size >= this.maxUsers) {
          this.log(`Room full, rejected: ${displayName}`, 'warn', true);
          // Send rejection message
          const rejectMsg = {
            id: this.generateId(),
            type: 'reject',
            sender: this.peerId,
            target: data.sender,
            reason: 'Room is full',
            timestamp: Date.now()
          };
          this.room.get('messages').get(rejectMsg.id).put(rejectMsg);
          return;
        }
        
        // Check password if set
        if (this.isHost && this.roomPassword && data.password !== this.roomPassword) {
          this.log(`Wrong password from: ${displayName}`, 'warn', true);
          const rejectMsg = {
            id: this.generateId(),
            type: 'reject',
            sender: this.peerId,
            target: data.sender,
            reason: 'Incorrect password',
            timestamp: Date.now()
          };
          this.room.get('messages').get(rejectMsg.id).put(rejectMsg);
          return;
        }
        
        this.log(`${displayName} joined`, 'success', true);
        
        this.peers.add(data.sender);
        this.peerInfo.set(data.sender, {
          username: displayName,
          color: this.generateColorFromString(data.sender)
        });
        
        // Store peer's SEA keys for encryption
        if (data.epub) {
          this.peerKeys.set(data.sender, { epub: data.epub, pub: data.pub });
        }
        
        // Host sends welcome with encrypted shared secret
        if (this.isHost && data.epub) {
          try {
            if (!this.seaKeyPair || !this.sharedSecret) {
              this.log('Cannot welcome new user: missing keys', 'error', true);
              return;
            }
            
            // Derive shared secret using ECDH via SEA
            const dhKey = await SEA.secret(data.epub, this.seaKeyPair);
            
            // Encrypt the room password using the ECDH key
            const encryptedSecret = await SEA.encrypt(this.sharedSecret, dhKey);
            
            // Build list of existing peers to share with new joiner
            const existingPeers = [];
            for (const [peerId, info] of this.peerInfo.entries()) {
              if (peerId !== data.sender) {
                existingPeers.push({ id: peerId, username: info.username });
              }
            }
            
            const welcomeMsg = {
              id: this.generateId(),
              type: 'welcome',
              sender: this.peerId,
              username: this.username,
              target: data.sender,
              epub: this.seaKeyPair.epub,
              pub: this.seaKeyPair.pub,
              encryptedSecret: encryptedSecret,
              peers: JSON.stringify(existingPeers),  // Send as JSON string for Gun
              timestamp: Date.now()
            };
            this.room.get('messages').get(welcomeMsg.id).put(welcomeMsg);
            this.connected = true;
            this.setStatus('connected');
          } catch (e) {
            this.log(`Key exchange error: ${e.message}`, 'error', true);
          }
        }
        this.updateConnectionInfo();
      }

      async handleWelcome(data) {
        if (data.target !== this.peerId) return;
        
        const hostName = data.username || 'Host';
        this.log(`Connected to ${hostName}'s room`, 'success', true);
        
        this.peers.add(data.sender);
        this.peerInfo.set(data.sender, {
          username: hostName,
          color: this.generateColorFromString(data.sender)
        });
        
        // Add existing peers from the host's list
        if (data.peers) {
          try {
            const existingPeers = JSON.parse(data.peers);
            for (const peer of existingPeers) {
              this.peers.add(peer.id);
              this.peerInfo.set(peer.id, {
                username: peer.username,
                color: this.generateColorFromString(peer.id)
              });
            }
            if (existingPeers.length > 0) {
              this.log(`Found ${existingPeers.length} other user(s) in room`, 'info', true);
            }
          } catch (e) {
            // Ignore parse errors
          }
        }
        
        // Store host's SEA keys
        if (data.epub) {
          this.peerKeys.set(data.sender, { epub: data.epub, pub: data.pub });
          
          // Decrypt shared secret from host using ECDH
          if (data.encryptedSecret) {
            try {
              // Derive the same shared key using ECDH
              const dhKey = await SEA.secret(data.epub, this.seaKeyPair);
              
              const decrypted = await SEA.decrypt(data.encryptedSecret, dhKey);
              
              if (decrypted) {
                this.sharedSecret = decrypted;
              } else {
                throw new Error('Decryption returned null');
              }
            } catch (e) {
              this.log(`Key exchange failed: ${e.message}`, 'error', true);
            }
          }
        }
        
        this.connected = true;
        this.setStatus('connected');
        this.updateConnectionInfo();
      }

      async handleMessage(data) {
        if (!data.encrypted) {
          return;
        }
        
        const sender = data.sender || 'Unknown';
        const peerInfo = this.peerInfo.get(sender) || { username: 'Anonymous', color: '#666' };
        
        if (!this.sharedSecret) {
          return; // Silently skip - we don't have the key yet
        }
        
        let message = null;
        try {
          message = await SEA.decrypt(data.encrypted, this.sharedSecret);
          if (!message) return; // Decryption failed, likely old message with different key
          // Ensure message is a string
          if (typeof message !== 'string') {
            message = String(message);
          }
          this.log(`Message from ${peerInfo.username}: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`, 'info');
        } catch (e) {
          return; // Silently fail - probably old message
        }
        
        this.messageCount++;
        this.lastMessageTime = new Date().toLocaleTimeString();
        this.onMessageReceived({ 
          sender, 
          username: peerInfo.username,
          color: peerInfo.color,
          message 
        });
        this.updateConnectionInfo();
      }

      handlePing(data) {
        const pongMsg = {
          id: this.generateId(),
          type: 'pong',
          sender: this.peerId,
          target: data.sender,
          pingId: data.id,
          timestamp: Date.now()
        };
        this.room.get('messages').get(pongMsg.id).put(pongMsg);
      }

      handlePong(data) {
        if (data.target !== this.peerId) return;
        // Silently handle pong - no logging needed
      }

      handleKick(data) {
        if (data.target !== this.peerId) return;
        this.log('You have been kicked from the room', 'error', true);
        this.setStatus('disconnected', 'Kicked by host');
        this.connected = false;
        this.peers.clear();
        this.peerInfo.clear();
        this.updateConnectionInfo();
        // Clear the room
        if (this.room) {
          this.room = null;
        }
      }

      handleKickNotify(data) {
        // Other clients get notified about the kick
        if (data.kickedPeer && this.peers.has(data.kickedPeer)) {
          const userInfo = this.peerInfo.get(data.kickedPeer);
          const username = userInfo ? userInfo.username : 'User';
          this.log(`${username} was kicked from the room`, 'warn', true);
          this.peers.delete(data.kickedPeer);
          this.peerInfo.delete(data.kickedPeer);
          this.peerKeys.delete(data.kickedPeer);
          this.peerLastSeen.delete(data.kickedPeer);
          this.updateConnectionInfo();
        }
      }

      handlePromote(data) {
        if (data.target !== this.peerId) {
          this.log(`Promote message not for me (target: ${data.target?.substring(0,8)}, me: ${this.peerId?.substring(0,8)})`, 'info');
          return;
        }
        this.log('You are now the host!', 'success', true);
        
        // Set host state
        this.isHost = true;
        this.sharedSecret = data.sharedSecret;
        this.maxUsers = data.maxUsers || 10;
        this.roomPassword = data.roomPassword || null;
        this.kickedUsers = new Set(data.kickedUsers || []);
        
        // Log for debugging
        console.log('=== HOST PROMOTION DEBUG ===');
        console.log('isHost:', this.isHost);
        console.log('sharedSecret:', this.sharedSecret);
        console.log('seaKeyPair:', this.seaKeyPair);
        console.log('onPromoted callback exists:', !!this.onPromoted);
        this.log(`Host state transferred: isHost=${this.isHost}, hasSharedSecret=${!!this.sharedSecret}, hasSEAKeyPair=${!!this.seaKeyPair}, onPromoted=${!!this.onPromoted}`, 'info');
        
        this.updateConnectionInfo();
        
        // Trigger UI update to show host controls
        if (this.onPromoted) {
          this.log('Calling onPromoted callback...', 'info');
          this.onPromoted();
        } else {
          this.log('ERROR: onPromoted callback not set!', 'error', true);
        }
      }

      handlePromoteNotify(data) {
        // Check if we're the new host
        if (data.newHost === this.peerId) {
          this.log('You are now the host!', 'success', true);
          
          // Set host state
          this.isHost = true;
          this.sharedSecret = data.sharedSecret;
          this.maxUsers = data.maxUsers || 10;
          this.roomPassword = data.roomPassword || null;
          // Parse kickedUsers from comma-separated string
          const kickedList = data.kickedUsers ? data.kickedUsers.split(',').filter(x => x) : [];
          this.kickedUsers = new Set(kickedList);
          
          this.updateConnectionInfo();
          
          // Trigger UI update
          if (this.onPromoted) {
            this.onPromoted();
          }
          return;
        }
        
        // All other clients get notified about host change
        const newHostInfo = this.peerInfo.get(data.newHost);
        const newHostName = newHostInfo ? newHostInfo.username : 'User';
        this.log(`${newHostName} is now the host`, 'info', true);
        this.updateConnectionInfo();
      }

      kickUser(peerId) {
        if (!this.isHost) return;
        
        const userInfo = this.peerInfo.get(peerId);
        const username = userInfo ? userInfo.username : 'User';
        
        this.kickedUsers.add(peerId);
        
        // Send kick message to the kicked user
        const kickMsg = {
          id: this.generateId(),
          type: 'kick',
          sender: this.peerId,
          target: peerId,
          timestamp: Date.now()
        };
        this.room.get('messages').get(kickMsg.id).put(kickMsg);
        
        // Notify all other peers about the kick
        const kickNotifyMsg = {
          id: this.generateId(),
          type: 'kick-notify',
          sender: this.peerId,
          kickedPeer: peerId,
          timestamp: Date.now()
        };
        this.room.get('messages').get(kickNotifyMsg.id).put(kickNotifyMsg);
        
        // Remove from local state
        this.peers.delete(peerId);
        this.peerInfo.delete(peerId);
        this.peerKeys.delete(peerId);
        this.peerLastSeen.delete(peerId);
        
        this.log(`Kicked ${username} from room`, 'warn', true);
        this.updateConnectionInfo();
      }

      promoteToHost(peerId) {
        if (!this.isHost) {
          this.log('Cannot promote: not host', 'error', true);
          return;
        }
        
        const userInfo = this.peerInfo.get(peerId);
        const username = userInfo ? userInfo.username : 'User';
        
        this.log(`Transferring host to ${username}...`, 'info', true);
        
        // Send promote-notify with all data (promote message doesn't sync reliably through Gun)
        const promoteNotifyMsg = {
          id: this.generateId(),
          type: 'promote-notify',
          sender: this.peerId,
          oldHost: this.peerId,
          newHost: peerId,
          sharedSecret: this.sharedSecret,
          maxUsers: this.maxUsers,
          roomPassword: this.roomPassword || '',
          kickedUsers: Array.from(this.kickedUsers).join(','),  // Convert to string for Gun
          timestamp: Date.now()
        };
        
        this.room.get('messages').get(promoteNotifyMsg.id).put(promoteNotifyMsg);
        
        // Transfer complete - demote self
        this.isHost = false;
        this.log(`${username} is now the host`, 'success', true);
        this.updateConnectionInfo();
      }

      sendPing() {
        if (!this.room) return;
        const pingMsg = {
          id: this.generateId(),
          type: 'ping',
          sender: this.peerId,
          timestamp: Date.now()
        };
        this.room.get('messages').get(pingMsg.id).put(pingMsg);
      }

      async sendMessage(text) {
        if (!this.room || !this.sharedSecret) {
          this.log('Cannot send: not connected or no shared key', 'error', true);
          return;
        }

        try {
          this.log(`Encrypting message: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}"`, 'info');
          
          // Encrypt using shared secret (simple string password)
          const encrypted = await SEA.encrypt(text, this.sharedSecret);
          this.log(`Message encrypted (length: ${encrypted?.length || 0})`, 'info');
          
          const msg = {
            id: this.generateId(),
            type: 'message',
            sender: this.peerId,
            encrypted: encrypted,
            timestamp: Date.now()
          };
          
          this.room.get('messages').get(msg.id).put(msg);
          this.log('Message sent to Gun network', 'info');
          
          this.messageCount++;
          this.lastMessageTime = new Date().toLocaleTimeString();
          this.updateConnectionInfo();
        } catch (e) {
          this.log(`Send error: ${e.message}`, 'error', true);
        }
      }

      updateConnectionInfo() {
        this.onConnectionInfo({
          peerId: this.peerId,
          roomId: this.roomId,
          isHost: this.isHost,
          connected: this.connected,
          peers: Array.from(this.peers),
          messageCount: this.messageCount,
          lastMessageTime: this.lastMessageTime
        });
      }

      generateQR(elementId, peerId) {
        const el = document.getElementById(elementId);
        el.innerHTML = '';
        new QRCode(el, {
          text: peerId,
          width: 256,
          height: 256,
          colorDark: "#667eea",
          colorLight: "#ffffff",
        });
        this.log('QR code generated', 'success');
      }

      async startQRScanner(videoElement, onScan) {
        this.log('Starting QR scanner...', 'info');
        
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            } 
          });
          
          videoElement.srcObject = stream;
          videoElement.style.display = 'block';
          
          const canvas = document.getElementById('canvas');
          const ctx = canvas.getContext('2d');
          let scanning = true;
          
          const scan = () => {
            if (!scanning) return;
            
            if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
              canvas.width = videoElement.videoWidth;
              canvas.height = videoElement.videoHeight;
              ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
              
              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const code = jsQR(imageData.data, imageData.width, imageData.height);
              
              if (code) {
                this.log(`QR code scanned: ${code.data}`, 'success', true);
                scanning = false;
                stream.getTracks().forEach(track => track.stop());
                videoElement.style.display = 'none';
                onScan(code.data);
                return;
              }
            }
            requestAnimationFrame(scan);
          };
          
          videoElement.addEventListener('loadeddata', () => {
            this.log('Camera ready, scanning...', 'info');
            scan();
          });
          
        } catch (err) {
          this.log(`Camera error: ${err.message}`, 'error');
        }
      }

      scanQRFromImage(imageFile, onScan) {
        this.log('Scanning QR from image...', 'info');
        
        const canvas = document.getElementById('qr-canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const code = jsQR(imageData.data, imageData.width, imageData.height);
          
          if (code) {
            this.log(`QR code found: ${code.data}`, 'success', true);
            onScan(code.data);
          } else {
            this.log(`No QR code found in image`, 'error');
          }
        };
        
        img.src = URL.createObjectURL(imageFile);
      }
    }

    // AppController - Manages UI and EnigmaJS integration
    class AppController {
      constructor() {
        this.enigmajs = null;
        this.currentMode = null;
        this.currentStream = null;
        this.verboseMode = false;
        this.notificationSound = null;
        this.notificationsEnabled = false;
        this.isPageVisible = true;
      }

      init() {
        this.log('App initialized', 'success');
        
        // Load dark mode preference
        const darkMode = localStorage.getItem('darkMode') === 'true';
        if (darkMode) {
          document.body.classList.add('dark-mode');
          document.getElementById('theme-icon').textContent = '‚òÄÔ∏è';
        }
        
        // Initialize notification sound (simple beep using Web Audio API)
        this.initNotificationSound();
        
        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
          Notification.requestPermission().then(permission => {
            this.notificationsEnabled = (permission === 'granted');
          });
        } else if ('Notification' in window && Notification.permission === 'granted') {
          this.notificationsEnabled = true;
        }
        
        // Track page visibility for notifications
        document.addEventListener('visibilitychange', () => {
          this.isPageVisible = !document.hidden;
        });
      }

      initNotificationSound() {
        // Create a simple notification beep using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        this.notificationSound = () => {
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();
          
          osc.connect(gain);
          gain.connect(audioContext.destination);
          
          osc.frequency.value = 800;
          osc.type = 'sine';
          
          gain.gain.setValueAtTime(0.3, audioContext.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
          
          osc.start(audioContext.currentTime);
          osc.stop(audioContext.currentTime + 0.3);
        };
      }

      toggleDarkMode() {
        const isDark = document.body.classList.toggle('dark-mode');
        const icon = document.getElementById('theme-icon');
        icon.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
        localStorage.setItem('darkMode', isDark);
      }

      setUsername() {
        const username = document.getElementById('user-display-name').value.trim();
        if (!username) {
          alert('Please enter a display name');
          return;
        }
        this.username = username;
        document.getElementById('username-setup').style.display = 'none';
        document.getElementById('mode-selection').style.display = 'block';
      }

      setMode(mode) {
        this.currentMode = mode;
        document.getElementById('mode-selection').style.display = 'none';
        document.querySelectorAll('.section').forEach(el => el.classList.remove('active'));
        
        if (mode === 'host') {
          document.getElementById('host-section').classList.add('active');
          this.initHost();
        } else if (mode === 'join') {
          document.getElementById('join-section').classList.add('active');
        }
      }

      initHost() {
        const username = this.username || 'Host';
        
        this.enigmajs = new EnigmaJS({
          username: username,
          onLog: (log) => this.addLog(log),
          onStatusChange: (status, error) => this.updateStatus('host', status, error),
          onConnection: (info) => this.handleConnection(info),
          onConnectionInfo: (info) => this.updateConnectionInfo('host', info),
          onMessageReceived: (msg) => this.displayMessage('host', msg),
          onPromoted: () => this.handlePromotion('host')
        });
        
        this.enigmajs.initHost().then(() => {
          document.getElementById('peer-id').textContent = this.enigmajs.roomId;
          this.enigmajs.generateQR('qrcode', this.enigmajs.roomId);
          this.enigmajs.setVerbose(this.verboseMode);
        });
      }

      connectManual() {
        const roomId = document.getElementById('peer-id-input').value.trim();
        if (!roomId) {
          alert('Please enter a room ID');
          return;
        }
        this.connectToRoom(roomId);
      }

      connectToRoom(roomId) {
        const username = this.username || 'Guest';
        
        document.getElementById('join-input-section').style.display = 'none';
        
        this.enigmajs = new EnigmaJS({
          username: username,
          onLog: (log) => this.addLog(log),
          onStatusChange: (status, error) => this.updateStatus('join', status, error),
          onConnection: (info) => this.handleConnection(info),
          onConnectionInfo: (info) => this.updateConnectionInfo('join', info),
          onMessageReceived: (msg) => this.displayMessage('join', msg),
          onPromoted: () => this.handlePromotion('join')
        });
        
        this.enigmajs.connectToPeer(roomId);
        this.enigmajs.setVerbose(this.verboseMode);
      }

      handleConnection(info) {
        if (info.type === 'host-ready') {
          this.addLog({ timestamp: new Date().toLocaleTimeString(), message: 'Host ready, waiting for peer...', type: 'success' });
        }
      }

      updateStatus(mode, status, error) {
        const statusEl = document.getElementById(`status-${mode}`);
        statusEl.className = `status ${status}`;
        
        const statusText = {
          'disconnected': '‚ùå Disconnected',
          'connecting': 'üîÑ Connecting...',
          'waiting': '‚è≥ Waiting for peer...',
          'connected': '‚úÖ Connected!'
        };
        
        statusEl.textContent = error || statusText[status] || status;
        
        // Update connection status field
        const connStatus = document.getElementById(`conn-status-${mode}`);
        if (connStatus) {
          connStatus.textContent = statusText[status] || status;
        }

        // Update badge based on status
        const badge = document.getElementById(`security-badge-${mode}`);
        if (status === 'connecting') {
          badge.textContent = 'CONNECTING...';
          badge.classList.remove('active');
          badge.style.background = 'linear-gradient(135deg, #FFA726 0%, #FB8C00 100%)';
        } else if (status === 'waiting') {
          badge.textContent = 'WAITING...';
          badge.classList.remove('active');
          badge.style.background = 'linear-gradient(135deg, #FFA726 0%, #FB8C00 100%)';
        } else if (status === 'disconnected') {
          badge.textContent = 'NOT CONNECTED';
          badge.classList.remove('active');
          badge.style.background = 'linear-gradient(135deg, #EF5350 0%, #E53935 100%)';
        }

        if (status === 'connected') {
          document.getElementById(`${mode}-chat`).style.display = 'block';
          document.getElementById(`${mode}-user-list`).style.display = 'block';
          
          // Setup scroll button visibility handler
          const messagesEl = document.getElementById(`${mode}-messages`);
          const scrollBtn = document.getElementById(`${mode}-scroll-btn`);
          
          messagesEl.addEventListener('scroll', () => {
            const isAtBottom = messagesEl.scrollHeight - messagesEl.scrollTop <= messagesEl.clientHeight + 50;
            if (isAtBottom) {
              scrollBtn.classList.remove('visible');
            } else {
              scrollBtn.classList.add('visible');
            }
          });
          
          // Update security badge to encrypted
          if (this.enigmajs && this.enigmajs.sharedSecret) {
            badge.textContent = 'ENCRYPTED';
            badge.classList.add('active');
            badge.style.background = 'linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%)';
          } else {
            badge.textContent = 'NOT ENCRYPTED';
            badge.classList.remove('active');
            badge.style.background = 'linear-gradient(135deg, #EF5350 0%, #E53935 100%)';
          }
        }
      }

      updateUserList(mode) {
        if (!this.enigmajs) return;
        
        const userListEl = document.getElementById(`${mode}-users`);
        const userCountEl = document.getElementById(`${mode}-user-count`);
        
        // Clear current list
        userListEl.innerHTML = '';
        
        // Add self to list
        const selfColor = this.enigmajs.generateColorFromString(this.enigmajs.peerId);
        const selfItem = document.createElement('div');
        selfItem.className = 'user-item';
        selfItem.innerHTML = `
          <div class="user-color-dot" style="background-color: ${selfColor};"></div>
          <span class="user-name">${this.escapeHtml(this.enigmajs.username)}</span>
          <span class="user-badge">You</span>
        `;
        userListEl.appendChild(selfItem);
        
        // Add all connected peers
        for (const [peerId, info] of this.enigmajs.peerInfo.entries()) {
          const userItem = document.createElement('div');
          userItem.className = 'user-item';
          
          const isHost = this.enigmajs.isHost;
          const actionsHtml = isHost ? `
            <button class="user-promote-btn" onclick="app.promoteUser('${peerId}')" title="Make Host">üëë</button>
            <button class="user-kick-btn" onclick="app.kickUser('${peerId}')" title="Kick User">‚úï</button>
          ` : '';
          
          userItem.innerHTML = `
            <div class="user-color-dot" style="background-color: ${info.color};"></div>
            <span class="user-name">${this.escapeHtml(info.username)}</span>
            ${actionsHtml}
          `;
          userListEl.appendChild(userItem);
        }
        
        // Update count (self + peers)
        const totalCount = 1 + this.enigmajs.peerInfo.size;
        userCountEl.textContent = totalCount;
      }

      updateConnectionInfo(mode, info) {
        // Update the combined security/connection info panel
        console.log(`updateConnectionInfo called: mode=${mode}, isHost=${info.isHost}, roomId=${info.roomId}`);
        
        const roleEl = document.getElementById(`conn-role-${mode}`);
        const roomEl = document.getElementById(`conn-room-${mode}`);
        const peersEl = document.getElementById(`conn-peers-${mode}`);
        const messagesEl = document.getElementById(`conn-messages-${mode}`);
        
        if (roleEl) {
          roleEl.textContent = info.isHost ? 'Host' : 'Client';
          console.log(`Role element updated to: ${roleEl.textContent}`);
        } else {
          console.log(`ERROR: Role element not found for mode ${mode}`);
        }
        if (roomEl) roomEl.textContent = info.roomId || '‚Äî';
        if (peersEl) peersEl.textContent = (info.peers.length + 1).toString(); // +1 for self
        if (messagesEl) messagesEl.textContent = info.messageCount.toString();
        
        // Update user list whenever connection info updates
        this.updateUserList(mode);
      }

      displayMessage(mode, msg) {
        const messagesEl = document.getElementById(`${mode}-messages`);
        const messageDiv = document.createElement('div');
        const textColor = this.enigmajs.getContrastingTextColor(msg.color);
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        messageDiv.className = 'message received';
        messageDiv.style.backgroundColor = msg.color;
        messageDiv.style.color = textColor;
        messageDiv.innerHTML = `
          <div class="message-sender" style="opacity: 0.8; font-weight: 600;">${this.escapeHtml(msg.username)}</div>
          <div>${this.escapeHtml(msg.message)}</div>
          <div style="font-size: 10px; opacity: 0.6; margin-top: 4px; text-align: right;">${timestamp}</div>
        `;
        messagesEl.appendChild(messageDiv);
        
        // Auto-scroll if already at bottom
        const isAtBottom = messagesEl.scrollHeight - messagesEl.scrollTop <= messagesEl.clientHeight + 50;
        if (isAtBottom) {
          messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        // Play notification sound
        if (this.notificationSound) {
          this.notificationSound();
        }
        
        // Show browser notification if tab is inactive
        if (!this.isPageVisible && this.notificationsEnabled) {
          this.showNotification(msg.username, msg.message);
        }
      }

      sendMessage() {
        const mode = this.currentMode;
        const inputEl = document.getElementById(`${mode}-input`);
        const text = inputEl.value.trim();
        
        if (!text) return;
        
        this.enigmajs.sendMessage(text);
        
        // Display sent message with colored bubble
        const messagesEl = document.getElementById(`${mode}-messages`);
        const messageDiv = document.createElement('div');
        const ownColor = this.enigmajs.generateColorFromString(this.enigmajs.peerId);
        const textColor = this.enigmajs.getContrastingTextColor(ownColor);
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        messageDiv.className = 'message sent';
        messageDiv.style.backgroundColor = ownColor;
        messageDiv.style.color = textColor;
        messageDiv.innerHTML = `
          <div class="message-sender" style="opacity: 0.8; font-weight: 600;">${this.escapeHtml(this.enigmajs.username)}</div>
          <div>${this.escapeHtml(text)}</div>
          <div style="font-size: 10px; opacity: 0.6; margin-top: 4px; text-align: right;">${timestamp}</div>
        `;
        messagesEl.appendChild(messageDiv);
        messagesEl.scrollTop = messagesEl.scrollHeight;
        
        inputEl.value = '';
      }

      showNotification(username, message) {
        if ('Notification' in window && Notification.permission === 'granted') {
          const notification = new Notification(`üí¨ ${username}`, {
            body: message.length > 50 ? message.substring(0, 47) + '...' : message,
            icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">üîê</text></svg>',
            badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">üí¨</text></svg>',
            tag: 'enigmajs-message',
            requireInteraction: false
          });
          
          notification.onclick = () => {
            window.focus();
            notification.close();
          };
          
          // Auto-close after 4 seconds
          setTimeout(() => notification.close(), 4000);
        }
      }

      scrollToBottom(mode) {
        const messagesEl = document.getElementById(`${mode}-messages`);
        messagesEl.scrollTo({
          top: messagesEl.scrollHeight,
          behavior: 'smooth'
        });
      }

      kickUser(peerId) {
        if (!this.enigmajs || !this.enigmajs.isHost) return;
        
        const userInfo = this.enigmajs.peerInfo.get(peerId);
        const username = userInfo ? userInfo.username : 'User';
        
        if (confirm(`Kick ${username} from the room?`)) {
          this.enigmajs.kickUser(peerId);
        }
      }

      promoteUser(peerId) {
        if (!this.enigmajs || !this.enigmajs.isHost) return;
        
        const userInfo = this.enigmajs.peerInfo.get(peerId);
        const username = userInfo ? userInfo.username : 'User';
        
        if (confirm(`Make ${username} the new host? You will lose host privileges.`)) {
          this.enigmajs.promoteToHost(peerId);
          
          // Hide host-specific UI elements when we lose host status
          this.hideHostUI(this.currentMode);
        }
      }
      
      hideHostUI(mode) {
        // Hide the QR code and room ID when we're no longer host
        if (mode === 'host') {
          // For original host mode, hide the wrapper div
          const roomInfo = document.getElementById('host-room-info');
          if (roomInfo) roomInfo.style.display = 'none';
        } else {
          // For join mode, remove the promoted-host-info element
          const promotedInfo = document.querySelector(`#${mode}-section .promoted-host-info`);
          if (promotedInfo) promotedInfo.remove();
        }
      }
      
      showHostUI(mode) {
        // Show the QR code and room ID when we become host
        if (mode === 'host') {
          // For original host mode, show the wrapper div
          const roomInfo = document.getElementById('host-room-info');
          if (roomInfo) roomInfo.style.display = 'block';
        }
        // For join mode, handlePromotion creates the elements
      }

      handlePromotion(mode) {
        // User was promoted to host - show host UI elements
        this.currentMode = mode;
        const section = document.getElementById(`${mode}-section`);
        
        // For host mode, just show the existing elements
        if (mode === 'host') {
          this.showHostUI(mode);
          this.updateUserList(mode);
          return;
        }
        
        // Hide the join input section if visible
        const joinInputSection = document.getElementById('join-input-section');
        if (joinInputSection) {
          joinInputSection.style.display = 'none';
        }
        
        // Show Room ID if not already visible
        let peerIdDisplay = section.querySelector('.promoted-host-info');
        if (!peerIdDisplay) {
          // Find the status element to insert after
          const statusEl = document.getElementById(`status-${mode}`);
          const infoDiv = document.createElement('div');
          infoDiv.className = 'promoted-host-info';
          infoDiv.innerHTML = `
            <p style="margin-top: 15px;">Your Room ID:</p>
            <div class="peer-id" id="promoted-peer-id-${mode}">${this.enigmajs.roomId}</div>
            <button class="btn-secondary" onclick="navigator.clipboard.writeText('${this.enigmajs.roomId}')" style="width: 100%; margin-top: 10px;">üìã Copy Room ID</button>
            <p style="margin-top: 15px; text-align: center; color: #666;">Scan this QR code to connect:</p>
            <div id="promoted-qrcode-${mode}" style="text-align: center;"></div>
          `;
          
          // Insert after status element
          if (statusEl) {
            statusEl.insertAdjacentElement('afterend', infoDiv);
          } else {
            // Fallback: insert after heading
            const heading = section.querySelector('h2');
            heading.insertAdjacentElement('afterend', infoDiv);
          }
          
          // Generate QR code
          setTimeout(() => {
            this.enigmajs.generateQR(`promoted-qrcode-${mode}`, this.enigmajs.roomId);
          }, 100);
        }
        
        // Force user list update to show host controls
        this.updateUserList(mode);
      }

      startScanner() {
        const videoEl = document.getElementById('video');
        document.getElementById('start-camera-btn').style.display = 'none';
        document.getElementById('stop-camera-btn').style.display = 'inline-block';
        document.getElementById('scan-hint').style.display = 'block';
        
        if (!this.enigmajs) {
          this.enigmajs = new EnigmaJS({
            onLog: (log) => this.addLog(log)
          });
        }
        
        this.enigmajs.startQRScanner(videoEl, (roomId) => {
          this.stopScanner();
          this.connectToRoom(roomId);
        });
      }

      stopScanner() {
        const videoEl = document.getElementById('video');
        if (videoEl.srcObject) {
          videoEl.srcObject.getTracks().forEach(track => track.stop());
          videoEl.srcObject = null;
        }
        videoEl.style.display = 'none';
        document.getElementById('start-camera-btn').style.display = 'inline-block';
        document.getElementById('stop-camera-btn').style.display = 'none';
        document.getElementById('scan-hint').style.display = 'none';
      }

      handleQRImage(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        if (!this.enigmajs) {
          this.enigmajs = new EnigmaJS({
            onLog: (log) => this.addLog(log)
          });
        }
        
        this.enigmajs.scanQRFromImage(file, (roomId) => {
          this.connectToRoom(roomId);
        });
      }

      toggleVerbose(enabled) {
        this.verboseMode = enabled;
        if (this.enigmajs) {
          this.enigmajs.setVerbose(enabled);
        }
        this.log(`Verbose logging ${enabled ? 'enabled' : 'disabled'}`, 'info');
      }

      toggleDebugPanel(mode) {
        const content = document.getElementById(`debug-content-${mode}`);
        const icon = document.getElementById(`debug-icon-${mode}`);
        
        if (content.classList.contains('expanded')) {
          content.classList.remove('expanded');
          icon.classList.remove('expanded');
        } else {
          content.classList.add('expanded');
          icon.classList.add('expanded');
        }
      }

      addLog(log) {
        const mode = this.currentMode || 'host';
        const logEl = document.getElementById(`log-console-${mode}`);
        if (!logEl) return;
        
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.innerHTML = `
          <span class="log-time">${log.timestamp}</span>
          <span class="log-${log.type}">${this.escapeHtml(log.message)}</span>
        `;
        logEl.appendChild(entry);
        logEl.scrollTop = logEl.scrollHeight;
        
        // Keep only last 100 entries
        while (logEl.children.length > 100) {
          logEl.removeChild(logEl.firstChild);
        }
      }

      log(message, type = 'info') {
        this.addLog({
          timestamp: new Date().toLocaleTimeString(),
          message: message,
          type: type
        });
      }

      escapeHtml(unsafe) {
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }
    }

    // Initialize app
    const app = new AppController();
    app.init();
  </script>
</body>
</html>
